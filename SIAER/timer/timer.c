// *************************************************************************************************
// Include section

// system
#include "includes.h"

// *************************************************************************************************
// Prototypes section
void Timer1_Init(void);
void Timer1_Start(void);
void Timer1_Stop(void);
char delay_over;

extern volatile char ed_send_request;
extern void Incrementa_timeout(void);
// *************************************************************************************************
// Defines section

// *************************************************************************************************
// Global Variable section

// *************************************************************************************************
// Extern section

// *************************************************************************************************
// @fn          Timer1_Init
// @brief       Set Timer1 para um periodo de 1 or 2 sec. IRQ TACCR0 is asserted when timer overflows.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_Init(void)
{
    // Set interrupt frequency to 1Hz
    TA1CCR0 = 32768 - 1;

    // Enable timer interrupt
    TA1CCTL0 |= CCIE;

    // Clear and start timer now
    // Continuous mode: Count to 0xFFFF and restart from 0 again - 1sec timing will be generated by
    // ISR
    TA1CTL |= TASSEL0 + MC1 + TACLR;
    
 __bis_SR_register(GIE); //enable interrupts
}

// *************************************************************************************************
// @fn          Timer1_Start
// @brief       Start Timer0.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_Start(void)
{
    // Start Timer0 in continuous mode
    TA1CTL |= MC_2;
}

// *************************************************************************************************
// @fn          Timer1_Stop
// @brief       Stop and reset Timer0.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_Stop(void)
{
    // Stop Timer0
    TA1CTL &= ~MC_2;

    // Set Timer0 count register to 0x0000
    TA1R = 0;
}

void Timer1_Delay(unsigned short ticks)
{
    unsigned short value = 0;

    // Exit immediately if Timer0 not running - otherwise we'll get stuck here
    if ((TA1CTL & (BIT4 | BIT5)) == 0)
        return;

    // Disable timer interrupt
    TA1CCTL1 &= ~CCIE;

    // Clear delay_over flag
    delay_over = 0;

    // Add delay to current timer value
    // To make sure this value is correctly read
    while (value != TA1R)
        value = TA1R;
    value += ticks;

    // Update CCR
    TA1CCR1 = value;

    // Reset IRQ flag
    TA1CCTL1 &= ~CCIFG;

    // Enable timer interrupt
    TA1CCTL1 |= CCIE;

    // Wait for timer IRQ
    while (1)
    {
        // Check stop condition
        // disable interrupt to prevent flag's change caused by interrupt methods
        if (delay_over)
            break;
    }
}


// Timer1 A0 interrupt service routine
#pragma vector=TIMER1_A0_VECTOR
__interrupt void TIMER1_A0_ISR(void)
{
	  // Disable IE
    TA1CCTL0 &= ~CCIE;
    // Reset IRQ flag
    TA1CCTL0 &= ~CCIFG;
    // Add 1 sec to TACCR0 register (IRQ will be asserted at 0x7FFF and 0xFFFF = 1 sec intervals)
    TA1CCR0 += 32768;
    // Enable IE
    TA1CCTL0 |= CCIE;
	
    ed_send_request = 1;

    // incrementar todos os timeouts dos buffers.
    // verificar se desconectou. 
    // organizar o buffer
    // decrementar o num de onibus conectados.
    // buffer. estado conexao = OFF;

	Incrementa_timeout();
}

// *************************************************************************************************
// @fn          Timer0_A1_5_ISR
// @brief       IRQ handler for timer IRQ.
//                              Timer0_A0       1/1sec clock tick (serviced by function
// TIMER0_A0_ISR)
//                              Timer0_A1       BlueRobin timer
//                              Timer0_A2       1/100 sec Stopwatch
//                              Timer0_A3       Configurable periodic IRQ (used by button_repeat and
// buzzer)
//                              Timer0_A4       One-time delay
// @param       none
// @return      none
// *************************************************************************************************
#pragma vector = TIMER1_A1_VECTOR
__interrupt void TIMER1_A1_5_ISR(void)
{
            TA1CCTL1 &= ~CCIE;
            // Reset IRQ flag
            TA1CCTL1 &= ~CCIFG;
            // Set delay over flag
            delay_over = 1;
}

